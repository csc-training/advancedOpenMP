# Tasks using the counter of the generating task.
    
## Background

Task Dependences in OpenMP are relative to previously generated sibling tasks.
For instance, in a while loop
```
       !$omp single
       do while(){
          !$omp task depend(...)
            ...
          !$omp end task
       end do
```
The 1st task generated has no dependence.
The 2nd task generated can only have a dependence on task 1 (task generated by 1st iteration).
The 3nd task generated can only have a dependence on task 1 and 2. (task created by 1st and 2nd iter.)
etc.

Potential dependences are discovered from identical variables (actually addresses
of the variable) found in the "list" of the depend clause.  Think of them as
identifiers.  The type of dependence is set by the dependence-type, and is 
characterized as IN(Read), OUT(Write) and INOUT(ReadWrite), as illustrated in
the syntax:
```
          depend(dependence-type:list)

          where dependence-type = (IN/OUT/INOUT)
          list = list of variable.
```
The basic dependency that can occur for two subsequent task generations are:
```
       RaW (Read after Write)
         ... omp task depend(OUT:x)
             foo(x)
         ... omp task depend( IN:x)
             foo(x)

       WaR (Write after Read)
         ... omp task depend( IN:x)
             foo(x)
         ... omp task depend(OUT:x)
             foo(x)

       WaW (Write after Write) 
         ... omp task depend(OUT:x)
             foo(x)
         ... omp task depend(OUT:x)
             foo(x)

       RaR (Read after Read)
         ... omp task depend(OUT:x)
             foo(x)
         ... omp task depend(OUT:x)
             foo(x)
```
Only the second task will depend upon the first task. (The first task has no
predecessor.) Only for the RaR case will the tasks be allowed to run simultaneously.
Certainly the dependencies get more complicated when there is a generator loop; but
here we test the 4 basic dependences in an exercise.


## Exercises

1.) READ each of the codes.

2.) Substitute the appropriate dependence type for the <???> characters in
    the depend clauses to make raw, rar, war, and waw dependence, according
    to the name of the file.

3.) Compile and execute them.
```
      ftn -O1  -fopenmp raw.F90 -o a.out.raw
      ftn -O1  -fopenmp rar.F90 -o a.out.rar
      ftn -O1  -fopenmp war.F90 -o a.out.war
      ftn -O1  -fopenmp waw.F90 -o a.out.waw
```
    For raw, war and waw, what is the expected printed value? _________
    For the  rar case what is the expected printed value?     _________
```
      export OMP_NUM_THREADS=1  #this make take over 1 min.
      for i in `seq 1 50`; do ./a.out.raw; done
      for i in `seq 1 50`; do ./a.out.rar; done
```
    Hmm? Convence your self that that RaR case is "always"
    printing 2 by executing: 
```
       for i in `seq 1 1000`; do ./a.out.rar; done | grep 1
```
    What do you think is the reason why we only see a value of 2
    for the RaR case here?  _________________________.
    (Hint immediate execution versus deferred.)

    Now try this with 2 threads.
```
   export OMP_NUM_THREADS=2
   for i in `seq 1 1000`; do ./a.out.rar; done | grep 1
```
       Here the tasks in the rar program will most likely
       run as deferred tasks. They can run in ANY order
       and probably concurrently (as deferred tasks with
       a team of 2 threads).
       This is when you will definitely see an ordering 
       difference or even a ______ condition
       for the one task that reads and the other that writes.

4.) (OPTIONAL)
    Someone thought it would be a good idea to put all of
    the tests in a single code, depend_all.F90, and
    execute it for each case, after re-initializing x.
    Hmm? The rules appear not to be behaving correctly, though!
    You should only see return values of 1 for RaR dependences.
    (But 1's appear for other cases.)
```
      ftn -fopenmp depend_all_broken.F90 -o a.out.all_broken

      export OMP_NUM_THREADS 2
      for i in `seq 1 1000`; do ./a.out.all_broken; done 
      or better
      for i in `seq 1 1000`; do ./a.out.all_broken; done | grep -v RaR | grep 1
                                                                    ^         ^
                                 filter RaR out (can be 1 or 2) ----|         | 
                                 Find any others that come up a 1-------------|
```   

    Correct the problem in the code, and show that the
    dependence tests will work correctly.  (Hint: think
    about race conditions when setting a shared variable.
    One easy way to fix this is with a barrier after resetting x.)
```
      !$omp barrier
```
    Copy depend_all_broke.F90 to depend_all_ok.F90
```
      ftn -fopenmp depend_all_ok.F90 -o a.out.all_ok
      export OMP_NUM_THREADS=2

      for i in `seq 1 1000`; do ./a.out.all_ok; done 
      or better
      for i in `seq 1 1000`; do ./a.out.all_ok; done | grep -v RaR | grep 1
```
   Of course the RAR dependences will print a 1 or 2.

   Answers provided in the hidden .answers directory.  Enjoy :)
